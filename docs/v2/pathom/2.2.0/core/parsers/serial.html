<!DOCTYPE html>
<html lang="en">
  <head>
      <!-- Global site tag (gtag.js) - Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-3833116-18"></script>
      <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-3833116-18');
      </script>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>Serial parsers | Pathom</title>
    <link rel="canonical" href="http://127.0.0.1:8080/pathom/2.2.0/core/parsers/serial.html">
    <link rel="stylesheet" href="../../../../assets/css/site.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" />
<link rel="stylesheet" href="../../../../assets/css/book.css">
<link rel="stylesheet" href="../../../../assets/css/codemirror.css">
    <link rel="schema.dcterms" href="https://purl.org/dc/terms/">
    <meta name="dcterms.subject" content="pathom">
    <meta name="dcterms.identifier" content="2.2.0">
    <meta name="generator" content="Antora 2.0.0">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar" id="topbar">
    <div class="container">
      <div id="topbar-menu" class="navbar-menu">
        <div class="navbar-start">
          <a class="navbar-item" href="http://127.0.0.1:8080">Pathom</a>

          <a class="navbar-item component" href="../../introduction.html"><span class="title">Pathom</span> <span class="version">2.2.0</span></a>
        </div>
        <div class="navbar-end">
          <a class="navbar-item navbar-icon-big" href="https://github.com/wilkerlucio/pathom"><i class="fa fa-github"></i></a>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body container">
<nav class="nav">
<div class="nav-menu">
<ul class="nav-list">
  <li class="nav-item is-active" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="../../introduction.html">Introduction</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <button class="nav-toggle"></button>
    <a class="nav-link" href="../../connect.html">Connect</a>
    </span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <span class="nav-line">
    <a class="nav-link" href="../../connect/basics.html">The Basics</a>
    </span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-line">
    <a class="nav-link" href="../../connect/resolvers.html">Resolvers</a>
    </span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-line">
    <a class="nav-link" href="../../connect/connect-mutations.html">Connect Mutations</a>
    </span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-line">
    <a class="nav-link" href="../../connect/shared-resolvers.html">Shared Resolvers</a>
    </span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-line">
    <a class="nav-link" href="../../connect/readers.html">Connect Readers</a>
    </span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-line">
    <a class="nav-link" href="../../connect/indexes.html">Understanding the Indexes</a>
    </span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-line">
    <a class="nav-link" href="../../connect/exploration.html">Exploration with Pathom Viz</a>
    </span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-line">
    <a class="nav-link" href="../../connect/thread-pool.html">Using a Thread Pool</a>
    </span>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="../../plugins.html">Plugins</a>
    </span>
  </li>
  <li class="nav-item is-current-path is-active" data-depth="1">
    <span class="nav-line">
    <button class="nav-toggle"></button>
    <a class="nav-link" href="../../core.html">Core Engine</a>
    </span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <span class="nav-line">
    <a class="nav-link" href="../getting-started.html">Getting Started</a>
    </span>
  </li>
  <li class="nav-item is-current-path is-active" data-depth="2">
    <span class="nav-line">
    <button class="nav-toggle"></button>
    <a class="nav-link" href="../parsers.html">Parsers</a>
    </span>
<ul class="nav-list">
  <li class="nav-item is-current-page is-active" data-depth="3">
    <span class="nav-line">
    <a class="nav-link" href="serial.html">Serial Parsers</a>
    </span>
  </li>
  <li class="nav-item" data-depth="3">
    <span class="nav-line">
    <a class="nav-link" href="parallel.html">Parallel Parser</a>
    </span>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-line">
    <a class="nav-link" href="../readers.html">Readers</a>
    </span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-line">
    <a class="nav-link" href="../entities.html">Entity</a>
    </span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-line">
    <a class="nav-link" href="../error-handling.html">Error handling</a>
    </span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-line">
    <a class="nav-link" href="../mutations.html">Mutations</a>
    </span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-line">
    <a class="nav-link" href="../request-cache.html">Request Caching</a>
    </span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-line">
    <a class="nav-link" href="../placeholders.html">Placeholders</a>
    </span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-line">
    <a class="nav-link" href="../trace.html">Tracing</a>
    </span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-line">
    <a class="nav-link" href="../path-track.html">Path tracking</a>
    </span>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="../../cljs-specs.html">Remove specs on Clojurescript</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="../../other-helpers.html">Other helpers</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <button class="nav-toggle"></button>
    <a class="nav-link" href="../../graphql.html">GraphQL Integration</a>
    </span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <span class="nav-line">
    <a class="nav-link" href="../../graphql/edn-to-gql.html">EDN&#8594;GraphQL</a>
    </span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-line">
    <a class="nav-link" href="../../graphql/fulcro.html">Fulcro Integration</a>
    </span>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="../../upgrade-guide.html">Upgrade Guide</a>
    </span>
  </li>
</ul>
  </li>
</ul>
</div>
</nav>
<aside class="toc sidebar">
  <div class="toc-menu"></div>
</aside>
<main class="article" data-ceiling="topbar">
  <div class="article-header">
<button class="nav-control"></button>
<nav class="crumbs" aria-label="breadcrumbs">
  <ul>
    <li class="crumb"><a href="../../introduction.html">Pathom</a></li>
    <li class="crumb"><a href="../../core.html">Core Engine</a></li>
    <li class="crumb"><a href="../parsers.html">Parsers</a></li>
    <li class="crumb"><a href="serial.html">Serial Parsers</a></li>
  </ul>
</nav>
<div class="tools" role="navigation">
  <ul>
    <li class="tool edit"><a href="file:///Users/wilker.lucio/Development/pathom/docs-src/modules/ROOT/pages/core/parsers/serial.adoc" title="Edit Page" target="_blank" rel="noopener">Edit</a></li>
  </ul>
</div>
  </div>
<article class="doc">
<h1 class="page">Serial parsers</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This is the simplest parser available, it doesn&#8217;t do more than a reduce, calling the reader
for each entry in the query.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_naive_parser"><a class="anchor" href="#_naive_parser"></a>Naive parser</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Just for improve understand, this is how we can implement a simple naive serial parser:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">; this a simple parser that reads entries from the env based on user query
(defn reduce-parser [env eql]
  (reduce
    (fn [out entry]
      (assoc out entry (get env entry)))
    {}
    eql))

; process EQL!
(reduce-parser {:foo "bar" :answer 42} [:answer])
; =&gt; {:answer 42}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s push a different query to our parser, adding a parameter to our entry:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">(reduce-parser {:foo "bar" :answer 42} ['(:answer {:with "param"})])
; =&gt; {(:answer {:with "param"}) nil}</code></pre>
</div>
</div>
<div class="paragraph">
<p>So that didn&#8217;t go so well, we got now a key out that includes the list, and no value.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_parsing_with_ast"><a class="anchor" href="#_parsing_with_ast"></a>Parsing with AST</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We could deal with this manually, checking for the list, but EQL has enough syntax that
this turns in trouble quickly. To fix this, instead of deal with the EQL directly, let&#8217;s
convert it to the <a href="https://edn-query-language.org/eql/1.0.0/specification.html">AST</a>
format and process that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">(defn reduce-parser [env eql]
  ; convert to ast
  (let [ast (eql/query-&gt;ast eql)]
    (reduce
      (fn [out {:keys [key]}]
        (assoc out key (get env key)))
      {}
      ; process children
      (:children ast))))

; now that we can get specific parts of entry, syntax details fade away
(reduce-parser {:foo "bar" :answer 42} [:answer])
; =&gt; {:answer 42}
(reduce-parser {:foo "bar" :answer 42} ['(:answer {:with "param"})])
; =&gt; {:answer 42}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may be thinking: what about nested queries?</p>
</div>
<div class="paragraph">
<p>And the answer is: the parser has nothing to do with that; let&#8217;s understand why.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_parsing_nested_queries"><a class="anchor" href="#_parsing_nested_queries"></a>Parsing nested queries</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Compare these two queries:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">[:a
 :b]

[:a
 {:b [:c]}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>How many elements each query have? And the answer is two, for both. It just
happens that in the second query, the second element is a join; but from the
parser&#8217;s point of view, in the first case it gets <code>:a</code> and <code>:b</code>, while in
the second case it gets <code>:a</code> and <code>{:b [:c]}</code>.</p>
</div>
<div class="paragraph">
<p>That&#8217;s the reason why it&#8217;s not valid to do multiple joins in the same map in EQL,
the map itself is considered one entry, because the parser sees it as one element.</p>
</div>
<div class="paragraph">
<p>Pathom processes sub-queries at the reader level. The reader can look at the
AST and see that element has <code>:children</code>, then it calls the parser again with the
children (and usually with some modifications to the environment) to process that
sub query.</p>
</div>
<div class="paragraph">
<p>To illustrate how the processing works, let&#8217;s use Pathom parser again:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">(def count-parser
  (p/parser {::p/env {::p/reader #(swap! (::counter %) inc)}}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This time we created a <code>count parser</code>, this parser will just increase a counter
and return its value, no matter what you ask, you can try it:</p>
</div>
<div x-app="interactive-parser" data-parser="core.parser-counter" data-no-trace class="loader">
[:a
 :b
 {:c
  [:d]}
 {:e
  [:f
   {:g
    [:h]}]}
 {:i
  [:j :k]}]
</div>
<div class="space"></div>
<div class="paragraph">
<p>Notice that if you do queries with joins, they will just be ignored, the reader returns
the value immediately. If we like to increase the counter only on the leaves, we can leverage
Pathom <a href="../readers.html#vector-dispatcher" class="page">reader composition</a> and put something before just to walk the joins.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">(defn join-walk-reader
  [{:keys [query] :as env}]
  (if query
    (p/join env)
    ::p/continue))

(def count-parser
  (p/parser {::p/env {::p/reader [join-walk-reader
                                  #(swap! (::counter %) inc)]}}))</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For our purposes <code>p/join</code> could be replace with a direct recursive call to the parser (which
is available at env as <code>:parser</code>). If you want to understand more about <code>p/join</code> check
<a href="../entities.html#_understanding_joins" class="page">core join docs</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Play around with the following example and see the ordering in which Pathom processes
the elements:</p>
</div>
<div x-app="interactive-parser" data-parser="core.parser-counter-nested" data-no-trace class="loader">
[:a
 :b
 {:c
  [:d]}
 {:e
  [:f
   {:g
    [:h]}]}
 {:i
  [:j :k]}]
</div>
<div class="space"></div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>By the previous description you may have realized, since readers process sub
queries, the result is a depth first pre-order traversal. To illustrate, think of the query:
 <code>[:a {:b [:c]} :d]</code>, the read order goes as: <span class="image"><img src="../../_images/serial-parser-traverse.png" alt="Serial parser traverse"></span></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These are the basics on the serial parser; and here is a list of things the Pathom parser
does on top of was discussed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Fill environment with <code>:ast</code>, <code>:parser</code> (itself) and <code>:query</code></p>
</li>
<li>
<p>Support <a href="../../plugins.html" class="page">plugins</a></p>
</li>
<li>
<p>Provide <code>::p/path</code> to allow for <a href="../path-track.html" class="page">path tracking</a></p>
</li>
<li>
<p>Support output renaming via <code>:pathom/as</code> parameter</p>
</li>
<li>
<p>Add parser related tracing events</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_async_parser"><a class="anchor" href="#_async_parser"></a>Async parser</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Some environments like browser Javascript require async operations to handle important
operations like HTTP fetching and IndexedDB. Going serial for those operations is not
an option. The async parser adds core.async channels support for async coordination.</p>
</div>
<div class="paragraph">
<p>The async parser is still a <strong>serial</strong> parser, and it will have the same flow characteristics
of the regular parser (the order or resolution is preserved).</p>
</div>
<div class="paragraph">
<p>To write an async parser we use the <code>p/async-parser</code> function. Here is an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">(ns com.wsscode.pathom.book.async.intro
  (:require [com.wsscode.pathom.core :as p]
            [cljs.core.async :as async :refer [go &lt;!]]
            [com.wsscode.pathom.profile :as pp]))

(defn sleep [n]
  (let [c (async/chan)]
    (js/setTimeout #(async/put! c ::done) n)
    c))

(def reader
  {:async-info
   (fn [_]
     (go
       (&lt;! (sleep (+ 100 (rand-int 1000))))
       "From async"))

   :foo
   (fn [_]
     "Regular")})

(def parser
  (p/async-parser {::p/plugins [(p/env-plugin {::p/reader reader})
                                pp/profile-plugin]}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Try the example:</p>
</div>
<div x-app="interactive-parser" data-parser="async.intro" class="loader">
[:foo :async-info]
</div>
<div class="space"></div>
<div class="paragraph">
<p>The core plugins work normally with the async parser, so error and profiling will work as expected.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_async_error_propagation"><a class="anchor" href="#_async_error_propagation"></a>Async Error propagation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When an exception occurs inside a core async channel the error is triggered as part of the channel exception handler.
That doesn&#8217;t compose very well, and for the parser needs it&#8217;s better if we have something more like the async/await
pattern used on JS environments. Pathom provides some macros to help making this a simple thing, instead of using
<code>go</code> and <code>&lt;!</code>, use the <code>go-catch</code> and <code>&lt;?</code> macros, as in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">(ns com.wsscode.pathom.book.async.error-propagation
  (:require [cljs.core.async :as async]
            [com.wsscode.common.async-cljs :refer [go-catch &lt;?]]
            [com.wsscode.pathom.core :as p]
            [com.wsscode.pathom.connect :as pc]))

(pc/defresolver async-info [_ _]
  {::pc/output [:async-info]}
  (go-catch
    (&lt;? (async/timeout (+ 100 (rand-int 1000))))
    {:async-info "From async"}))

(pc/defresolver async-error [_ _]
  {::pc/output [:async-error]}
  (go-catch
    ; &lt;? macro will re-throw any exception that get read from the channel
    (&lt;? (async/timeout (+ 100 (rand-int 1000))))
    (throw (ex-info "Error!!" {}))))

(pc/defresolver foo [_ _]
  {::pc/output [:foo]}
  {:foo "Regular"})

(def parser
  (p/async-parser
    {::p/env     {::p/reader [p/map-reader
                              pc/async-reader2]}
     ::p/plugins [(pc/connect-plugin {::pc/register [async-info async-error foo]})
                  p/error-handler-plugin
                  p/trace-plugin]}))</code></pre>
</div>
</div>
<div x-app="interactive-parser" data-parser="async.error-propagation" class="loader">
[:foo :async-info :async-error]
</div>
<div class="space"></div>
<div class="paragraph">
<p>Use <code>com.wsscode.common.async-clj</code> for Clojure and <code>com.wsscode.common.async-cljs</code> for ClojureScript. If you writing a
cljc file, use the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">[#?(:clj  com.wsscode.common.async-clj
    :cljs com.wsscode.common.async-cljs)
 :refer [go-catch &lt;?]]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_async_and_js_promises"><a class="anchor" href="#_async_and_js_promises"></a>Async and JS Promises</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In JS world most of the current async responses comes as promises, you can use the <code>&lt;!p</code> macro to read from promises
inside <code>go</code> blocks as if they were channels. Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">(ns com.wsscode.pathom.book.async.js-promises
  (:require [com.wsscode.common.async-cljs :refer [go-catch &lt;!p]]
            [com.wsscode.pathom.core :as p]
            [goog.object :as gobj]))

(def reader
  {:dog.ceo/random-dog-url
   (fn [_]
     (go-catch
       (-&gt; (js/fetch "https://dog.ceo/api/breeds/image/random") &lt;!p
           (.json) &lt;!p
           (gobj/get "message"))))})

(def parser
  (p/async-parser {::p/plugins [(p/env-plugin {::p/reader reader})
                                p/error-handler-plugin
                                p/trace-plugin]}))</code></pre>
</div>
</div>
<div x-app="interactive-parser" data-parser="async.js-promises" class="loader">
[:dog.ceo/random-dog-url]
</div>
<div class="space"></div>
</div>
</div>
</article>
</main>
</div>
<footer class="footer">
  <div class="container">
    <div class="footer-terms">
      <span>Documentation generated by <a href="https://antora.org/">Antora</a>, theme forked from <a href="https://github.com/couchbase/docs-ui">Couchbase Docs UI</a>.</span>
    </div>
  </div>
</footer>
<script src="../../../../assets/js/site.js"></script>
<script async src="../../../../assets/js/vendor/highlight.js"></script>
<script src="../../../../assets/js/book/main.js"></script>

  </body>
</html>
