{"version":3,"sources":["com/wsscode/pathom/diplomat/http.cljc"],"mappings":"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","names":["cljs.spec.alpha/def-impl","cljs.spec.alpha/with-gen","cljs.core/keyword?","cljs.spec.alpha.gen","cljs.core/string?","cljs.spec.alpha.every_impl","cljs.spec.alpha.tuple_impl","G__71699","cljs.core/coll?","G__71697","cljs.core/map?","i__13227__auto__","v__13228__auto__","cljs.core.nth","cljs.spec.alpha/or-spec-impl","cljs.core/any?","cljs.core/boolean?","cljs.spec.alpha/map-spec-impl","G__71711","cljs.core/contains?","G__71736","cljs.core/fn?","var_args","G__71773","com.wsscode.pathom.diplomat.http/request","js/Error","p__71781","map__71784","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","cljs.core.get","p__71790","map__71792","p__71798","map__71803","driver","request","url","G__71794","cljs.core.assoc","config","G__71807","cljs.core.merge","p__71814","map__71815","com.wsscode.pathom.diplomat.http/request-method","method","form-params","or__4131__auto__","G__71820","cljs.core/name","com.wsscode.pathom.diplomat.http/encode-type->header","encode-type","cljs.core/Keyword"],"sourcesContent":["(ns com.wsscode.pathom.diplomat.http\n  (:require\n    [clojure.spec.alpha :as s]\n    [com.fulcrologic.guardrails.core :refer [>def >defn >fdef => | <- ?]]))\n\n(>def ::encode-type (s/with-gen keyword? #(s/gen #{::transit+json ::edn ::json})))\n\n(>def ::url string?)\n\n(>def ::method #{::get ::head ::post ::put ::patch ::delete ::connect ::options})\n\n;; HTTP driver should always normalize the header name from HTTP-Case to :lower-case-keyword.\n;; HTTP1.1 use HTTP-Case, HTTP2 use lower-case. Always normalize it a good aproach used by\n;; pedestal and many others.\n;; A header can be sent multiple times. So it should be a coll-of values.\n;; Multiple values are supported both in java.net.http(req/res) and js/fetch(res).\n(>def ::headers (s/map-of string? (s/coll-of string?)))\n\n;; content-type will generate a header on request. it can be overwriten by passing a explicit content-type\n;; key on headers map. The driver will use this to convert ::form-params into ::body\n;; If absent, the driver should use ::body with no transformation and ::form-params will be ignored\n;; If it's a raw string, it will generate the header, but the driver should use raw ::body\n(>def ::content-type (s/or :pre-defined ::encode-type :raw string?))\n\n;; accept will generate a header on request.  it can be overwriten by passing a explicit accept\n;; key on headers map. The driver will use this to convert the response from server into ::body\n;; If it's a raw string, it will just generate the header.\n;; If absent or a raw string, the driver can (or not) use the content-type from response-header to convert.\n(>def ::accept (s/or :pre-defined ::encode-type :raw string?))\n\n;; Will say how to turn ::form-params into body on request and how to parse the response body.\n;; If content-type and/or accept are specifieds as :pre-defined, they will be preferred.\n(>def ::as ::encode-type)\n\n;; Used to generate ::body basead on ::content-type on request.\n;; Usualy a clojure data-structure\n(>def ::form-params any?)\n\n;; enable/disable tracing\n(>def ::debug? boolean?)\n\n;; On request, usually string, bytes, buffer or a writer.\n;; On response, should be a clojure data-structure.\n(>def ::body any?)\n\n(>def ::request\n  (s/keys\n    :req [::url]\n    :opt [::method\n          ::headers\n          ::content-type\n          ::accept\n          ::as\n          ::form-params\n          ::debug?\n          ::body]))\n\n(>def ::response\n  (s/keys\n    :req [::status]\n    :opt [::headers\n          ::body]))\n\n(>def ::driver fn?)\n\n(defn request\n  ([{::keys [driver] :as request}]\n   (driver request))\n  ([{::keys [driver] :as request} url]\n   (driver (assoc request ::url url)))\n  ([{::keys [driver] :as request} url config]\n   (driver (merge request {::url url} config))))\n\n(defn request-method [{::keys [method form-params]}]\n  (or (some-> method name)\n      (if form-params \"post\" \"get\")))\n\n(defn encode-type->header [encode-type]\n  (cond\n    (string? encode-type)\n    encode-type\n\n    (keyword? encode-type)\n    (str \"application/\" (name encode-type))))\n"]}