{"version":3,"sources":["fulcro/util.cljc"],"mappings":"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","names":["fulcro.util/force-children","x","G__58207","cljs.core/seq?","cljs.core.into","cljs.core.map","fulcro.util/union?","expr","G__58208","cljs.core/first","cljs.core/map?","cljs.core/second","fulcro.util/join?","fulcro.util/ident?","cljs.core/vector?","cljs.core/count","cljs.core/Keyword","cljs.core.nth","fulcro.util/join-entry","vec__58213","k","v","cljs.core/ffirst","cljs.core/list?","fulcro.util/join-key","G__58216","fulcro.util/join-value","join","fulcro.util/mutation-join?","cljs.core/Symbol","fulcro.util/unique-ident?","cljs.core._EQ_","fulcro.util/recursion?","cljs.core/symbol-identical?","fulcro.util/mutation?","G__58221","js/Error","fulcro.util/mutation-key","fulcro.util/unique-key","s","cljs.core/random-uuid","fulcro.util/atom?","a","cljs.core/Atom","var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","fulcro.util/deep-merge","seq58229","self__4718__auto__","cljs.core/seq","xs","cljs.core/every?","cljs.core.apply","cljs.core/merge-with","cljs.core/last","fulcro.util/conform!","spec","rt","cljs.spec.alpha/conform","cljs.spec.alpha/invalid?","cljs.core.ex_info","cljs.spec.alpha/explain-str","cljs.spec.alpha/explain-data","fulcro.util/soft-invariant","msg","fulcro.logging._log","e58233","e__55143__auto__","fulcro.util/__integrate-ident-impl__","seq58238","G__58240","cljs.core/next","G__58241","self__4717__auto__","state","ident","named-parameters","actions","cljs.core.partition","cljs.core.reduce","p__58243","vec__58244","command","data-path","already-has-ident-at-path?","p1__58236#","cljs.core/some","cljs.core.get_in","G__58247","p1__58237#","cljs.core.update_in","cljs.core.fnil","cljs.core/conj","path-to-vector","cljs.core/butlast","to-many?","index","vector","cljs.core/contains?","cljs.core/assoc-in"],"sourcesContent":["(ns fulcro.util\n  (:refer-clojure :exclude [ident?])\n  (:require\n    [clojure.spec.alpha :as s]\n    clojure.walk\n    [fulcro.logging :as log]\n    #?@(:clj\n        [[clojure.stacktrace :as strace]\n         [clojure.spec.gen.alpha :as sg]]))\n  #?(:clj\n     (:import (clojure.lang Atom))))\n\n(defn force-children [x]\n  (cond->> x\n    (seq? x) (into [] (map force-children))))\n\n(defn union?\n  #?(:cljs {:tag boolean})\n  [expr]\n  (let [expr (cond-> expr (seq? expr) first)]\n    (and (map? expr)\n      (map? (-> expr first second)))))\n\n(defn join? [x]\n  #?(:cljs {:tag boolean})\n  (let [x (if (seq? x) (first x) x)]\n    (map? x)))\n\n(defn ident?\n  \"Returns true if x is an ident.\"\n  #?(:cljs {:tag boolean})\n  [x]\n  (and (vector? x)\n    (== 2 (count x))\n    (keyword? (nth x 0))))\n\n(defn join-entry [expr]\n  (let [[k v] (if (seq? expr)\n                (ffirst expr)\n                (first expr))]\n    [(if (list? k) (first k) k) v]))\n\n(defn join-key [expr]\n  (cond\n    (map? expr) (let [k (ffirst expr)]\n                  (if (list? k)\n                    (first k)\n                    (ffirst expr)))\n    (seq? expr) (join-key (first expr))\n    :else expr))\n\n(defn join-value [join]\n  (second (join-entry join)))\n\n(defn mutation-join? [expr]\n  (and (join? expr) (symbol? (join-key expr))))\n\n(defn unique-ident?\n  #?(:cljs {:tag boolean})\n  [x]\n  (and (ident? x) (= '_ (second x))))\n\n(defn recursion?\n  #?(:cljs {:tag boolean})\n  [x]\n  (or #?(:clj  (= '... x)\n         :cljs (symbol-identical? '... x))\n    (number? x)))\n\n(defn mutation?\n  #?(:cljs {:tag boolean})\n  [expr]\n  (or (mutation-join? expr) (symbol? (cond-> expr (seq? expr) first))))\n\n(defn mutation-key [expr]\n  {:pre [(symbol? (first expr))]}\n  (first expr))\n\n(defn unique-key\n  \"Get a unique string-based key. Never returns the same value.\"\n  []\n  (let [s #?(:clj (java.util.UUID/randomUUID)\n             :cljs (random-uuid))]\n    (str s)))\n\n(defn atom? [a] (instance? Atom a))\n\n(defn deep-merge [& xs]\n  \"Merges nested maps without overwriting existing keys.\"\n  (if (every? map? xs)\n    (apply merge-with deep-merge xs)\n    (last xs)))\n\n(defn conform! [spec x]\n  (let [rt (s/conform spec x)]\n    (when (s/invalid? rt)\n      (throw (ex-info (s/explain-str spec x)\n               (s/explain-data spec x))))\n    rt))\n\n(defn soft-invariant\n  \"Logs the given message if v is false.\"\n  [v msg]\n  (when-not v (log/error \"Invariant failed\")))\n\n#?(:clj\n   (def TRUE (s/with-gen (constantly true) sg/int)))\n\n#?(:clj\n   (defn resolve-externs\n     \"Ensures the given needs are loaded, and resolved. Updates inmap to include all of the function symbols that were requested\n     as namespaced symbols.\n\n     inmap - A map (nil/empty)\n     needs - A sequence: ([namespace [f1 f2]] ...)\n\n     Returns a map keyed by namespaced symbol whose value is the resolved function:\n\n     {namespace/f1 (fn ...)\n      namespace/h2 (fn ...)\n      ...}\n\n     Logs a detailed error message if it fails.\n     \"\n     [inmap needs]\n     (reduce (fn [m [nmspc fns]]\n               (try\n                 (require nmspc)\n                 (let [n       (find-ns nmspc)\n                       fn-keys (map #(symbol (name nmspc) (name %)) fns)\n                       fnmap   (zipmap fn-keys (map #(or (ns-resolve n %) (throw (ex-info \"No such symbol\" {:ns nmspc :s %}))) fns))]\n                   (merge m fnmap))\n                 (catch Exception e\n                   (log/error (str \"Failed to load functions from \" nmspc \". Fulcro does not have hard dependencies on that library, and you must explicitly add the dependency to your project.\"))\n                   (log/error (with-out-str (strace/print-cause-trace e))))))\n       (or inmap {})\n       needs)))\n\n#?(:clj\n   (defn load-libs\n     \"Load libraries in Clojure dynamcically. externs is an atom that will hold the resulting resolved FQ symbols. needs\n     is a list of needs as specified in `fulcro.util/resolve-externs`.\"\n     [externs needs]\n     (when (or (nil? @externs) (empty? @externs))\n       (swap! externs resolve-externs needs))))\n\n#?(:clj\n   (defn build-invoke\n     \"Builds a function that can invoke a fq symbol by name. The returned function:\n\n     - Ensures the specified needs are loaded (fast once loaded)\n     - Looks up the function (cached)\n     - Runs the function\n\n     externs is an empty atom (which will be populated to cache the resolved functions)\n     needs is a map as specified in `resolve-externs`\n\n     ```\n     (def externs (atom nil))\n     (def invoke (fulcro.util/build-invoke externs '([bidi.bidi [bidi-match]])))\n\n     ...\n     (invoke 'bidi.bidi/bidi-match routes uri :request-method method)\n     ```\n\n     The generated invoke will attempt to load the function if it isn't yet loaded, and throws\n     an exception if the function isn't found.\n\n     The special fnsym 'noop will trigger loads without calling anything.\"\n     [externs needs]\n     (fn [fnsym & args]\n       (load-libs externs needs)\n       (when-not (= 'noop fnsym)\n         (if-let [f (get @externs fnsym)]\n           (apply f args)\n           (throw (ex-info \"Dynamically loaded function not found. You forgot to add a dependency to your classpath.\"\n                    {:sym fnsym})))))))\n\n\n(defn __integrate-ident-impl__\n  \"DO NOT USE!\n\n  This logic is held here because it was originally in\n  fulcro.client.primitives, but we wanted to deprecate that, move it into\n  fulcro.client.mutations, and reference the mutations implementation from\n  primitives. However the mutations namespace already depends on the primitives\n  namespace. So we put the logic here and reference it from both places.\"\n  [state ident & named-parameters]\n  (let [actions (partition 2 named-parameters)]\n    (reduce (fn [state [command data-path]]\n              (let [already-has-ident-at-path? (fn [data-path] (some #(= % ident) (get-in state data-path)))]\n                (case command\n                  :prepend (if (already-has-ident-at-path? data-path)\n                             state\n                             (update-in state data-path #(into [ident] %)))\n                  :append (if (already-has-ident-at-path? data-path)\n                            state\n                            (update-in state data-path (fnil conj []) ident))\n                  :replace (let [path-to-vector (butlast data-path)\n                                 to-many?       (and (seq path-to-vector) (vector? (get-in state path-to-vector)))\n                                 index          (last data-path)\n                                 vector         (get-in state path-to-vector)]\n                             (assert (vector? data-path) (str \"Replacement path must be a vector. You passed: \" data-path))\n                             (when to-many?\n                               (do\n                                 (assert (vector? vector) \"Path for replacement must be a vector\")\n                                 (assert (number? index) \"Path for replacement must end in a vector index\")\n                                 (assert (contains? vector index) (str \"Target vector for replacement does not have an item at index \" index))))\n                             (assoc-in state data-path ident))\n                  (throw (ex-info \"Unknown post-op to merge-state!: \" {:command command :arg data-path})))))\n      state actions)))\n"]}