{
"version":3,
"file":"module$com$wsscode$pathom$viz$pathom_mode.js",
"lineCount":10,
"mappings":"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",
"sources":["com/wsscode/pathom/viz/pathom-mode.js"],
"sourcesContent":["shadow$provide[\"module$com$wsscode$pathom$viz$pathom_mode\"] = function(global,require,module,exports) {\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Author: Wilker Lucio\n * Branched from CodeMirror's Clojure mode (by Hans Engel, based on implementation by Koh Zi Han)\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"pathom\", function (options) {\n    const BUILTIN = \"builtin\", COMMENT = \"comment\", STRING = \"string\", CHARACTER = \"string-2\",\n      ATOM = \"atom\", ATOM_IDENT = \"atom-ident\", ATOM_COMP = \"atom-composite\", NUMBER = \"number\", BRACKET = \"bracket\", KEYWORD = \"keyword\", VAR = \"constiable\";\n    const INDENT_WORD_SKIP = options.indentUnit || 2;\n    const NORMAL_INDENT_UNIT = options.indentUnit || 2;\n\n    const tests = {\n      digit: /\\d/,\n      digit_or_colon: /[\\d:]/,\n      hex: /[0-9a-f]/i,\n      sign: /[+-]/,\n      exponent: /e/i,\n      keyword_char: /[^\\s\\(\\[\\;\\)\\]]/,\n      symbol: /[\\w*+!\\-\\._?:<>\\/\\xa1-\\uffff]/,\n      block_indent: /^(?:def|with)[^\\/]+$|\\/(?:def|with)/\n    };\n\n    function pushStack(state, stack) {\n      stack.prev = state.pathStack;\n      state.pathStack = stack;\n      state.mode = stack.mode;\n    }\n\n    function popStack(state) {\n      state.pathStack = state.pathStack.prev;\n      state.mode = state.pathStack.mode;\n    }\n\n    function readNumber(ch, stream){\n      // hex\n      if ( ch === '0' && stream.eat(/x/i) ) {\n        stream.eatWhile(tests.hex);\n        return true;\n      }\n\n      // leading sign\n      if ( ( ch == '+' || ch == '-' ) && ( tests.digit.test(stream.peek()) ) ) {\n        stream.eat(tests.sign);\n        ch = stream.next();\n      }\n\n      if ( tests.digit.test(ch) ) {\n        stream.eat(ch);\n        stream.eatWhile(tests.digit);\n\n        if ( '.' == stream.peek() ) {\n          stream.eat('.');\n          stream.eatWhile(tests.digit);\n        } else if ('/' == stream.peek() ) {\n          stream.eat('/');\n          stream.eatWhile(tests.digit);\n        }\n\n        if ( stream.eat(tests.exponent) ) {\n          stream.eat(tests.sign);\n          stream.eatWhile(tests.digit);\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n\n    // Eat character that starts after backslash \\\n    function eatCharacter(stream) {\n      let first = stream.next();\n      // Read special literals: backspace, newline, space, return.\n      // Just read all lowercase letters.\n      if (first && first.match(/[a-z]/) && stream.match(/[a-z]+/, true)) {\n        return;\n      }\n      // Read unicode character: \\u1000 \\uA0a1\n      if (first === \"u\") {\n        stream.match(/[0-9a-z]{4}/i, true);\n      }\n    }\n\n    function readSymbol(stream) {\n      stream.eatWhile(tests.symbol);\n\n      return ATOM;\n    }\n\n    function readJoin(stream, state) {\n      pushStack(state, {mode: \"join\", indent: nextIndent(stream)});\n\n      return BRACKET;\n    }\n\n    function readIdent(stream, state) {\n      pushStack(state, {mode: \"ident\", indent: nextIndent(stream)});\n\n      return BRACKET;\n    }\n\n    function readParamExp(stream, state) {\n      pushStack(state, {mode: \"param-exp\", indent: nextIndent(stream)});\n\n      return BRACKET;\n    }\n\n    function nextIndent(stream) {\n      return stream.column() + stream.current().length;\n    }\n\n    function makeToken(stream, state) {\n      const string = stream.current();\n      const start = stream.column();\n      const end = start + string.length;\n\n      return {state: state, string: string, type: \"atom\", start: start, end: end};\n    }\n\n    const pathomCM = com.wsscode.pathom.viz.codemirror;\n\n    function atomOrComp(stream, state) {\n      if (!options.pathomIndex) return ATOM;\n\n      const token = makeToken(stream, state);\n      const words = pathomCM.completions(cljsDeref(options.pathomIndex), token, token.string);\n\n      if (pathomCM.key_has_children_QMARK_(words, token)) {\n        return ATOM_COMP;\n      } else {\n        return ATOM;\n      }\n    }\n\n    return {\n      startState: function () {\n        return {\n          pathStack: {},\n          indentation: 0,\n          mode: null\n        };\n      },\n\n      token: function (stream, state) {\n        let ch, stack = state.pathStack;\n\n        if (stack == null && stream.sol()) {\n          // update indentation, but only if indentStack is empty\n          state.indentation = stream.indentation();\n        }\n\n        // skip spaces\n        if (state.mode != \"string\" && stream.eatSpace()) {\n          return null;\n        }\n\n        switch(state.mode) {\n          case \"string\": // multi-line string parsing mode\n            let next, escaped = false;\n            while ((next = stream.next()) != null) {\n              if (next == \"\\\"\" && !escaped) {\n                popStack(state);\n                break;\n              }\n              escaped = !escaped && next == \"\\\\\";\n            }\n\n            return STRING;\n\n          case \"attr-list\":\n            ch = stream.next();\n\n            if (ch == \":\") {\n              readSymbol(stream);\n\n              return atomOrComp(stream, state);\n            }\n\n            if (ch == \"*\") return ATOM;\n\n            if (ch == \"[\") return readIdent(stream, state);\n            if (ch == \"]\") { popStack(state); return BRACKET; }\n\n            if (ch == \"{\") return readJoin(stream, state);\n            if (ch == \"(\") return readParamExp(stream, state);\n\n            break;\n\n          case \"join\":\n            ch = stream.next();\n\n            if (!stack.key) {\n              if (ch == \":\") {\n                readSymbol(stream);\n\n                stack.key = stream.current();\n\n                return atomOrComp(stream, state);\n              }\n\n              if (ch == \"[\") return readIdent(stream, state);\n              if (ch == \"(\") return readParamExp(stream, state);\n            } else {\n              if (ch == \"[\") {\n                pushStack(state, {mode: \"attr-list\", indent: nextIndent(stream)});\n\n                return BRACKET;\n              }\n            }\n\n            if (ch == \"}\") {\n              popStack(state);\n\n              if (stack.prev.mode == \"param-exp\") stack.prev.key = stack;\n\n              return BRACKET;\n            }\n\n            break;\n\n          case \"ident\":\n            ch = stream.next();\n\n            if (ch == \":\") {\n              readSymbol(stream);\n\n              if (!stack.key) stack.key = stream.current();\n\n              return ATOM_IDENT;\n            }\n\n            if (ch == \"\\\"\") {\n              pushStack(state, {mode: \"string\", indent: nextIndent(stream)});\n\n              return STRING;\n            }\n\n            if (readNumber(ch,stream)) {\n              return NUMBER;\n            }\n\n            if (ch == \"]\") {\n              popStack(state);\n\n              if (stack.prev.mode == \"join\" || stack.prev.mode == \"param-exp\")\n                stack.prev.key = stack;\n\n              return BRACKET;\n            }\n\n            readSymbol(stream);\n\n            return VAR;\n\n          case \"param-exp\":\n            ch = stream.next();\n\n            if (!stack.key) {\n              if (ch == \":\") {\n                readSymbol(stream);\n\n                stack.key = stream.current();\n\n                return atomOrComp(stream, state);\n              }\n\n              if (ch == \"[\") return readIdent(stream, state);\n              if (ch == \"{\") return readJoin(stream, state);\n\n              if (ch != \")\") {\n                readSymbol(stream);\n\n                stack.key = stream.current();\n\n                return VAR;\n              }\n            } else {\n              if (ch == \"{\") {\n                pushStack(state, {mode: \"param-map\", indent: nextIndent(stream)});\n\n                return BRACKET;\n              }\n            }\n\n            if (ch == \")\") {\n              popStack(state);\n\n              if (stack.prev.mode == \"join\") stack.prev.key = stack.key;\n\n              return BRACKET;\n            }\n\n            break;\n\n          case \"param-map\":\n            ch = stream.next();\n\n            if (ch == \":\") {\n              readSymbol(stream);\n\n              return ATOM;\n            }\n\n            if (ch == \"\\\"\") {\n              pushStack(state, {mode: \"string\", indent: nextIndent(stream)});\n\n              return STRING;\n            }\n\n            if (readNumber(ch,stream)) {\n              return NUMBER;\n            }\n\n            if (ch == \"}\") { popStack(state); return BRACKET; }\n\n            readSymbol(stream);\n\n            return VAR;\n\n          default: // default parsing mode\n            ch = stream.next();\n\n            if (ch == \"[\") {\n              pushStack(state, {mode: \"attr-list\", indent: nextIndent(stream)});\n\n              return BRACKET;\n            }\n        }\n\n        stream.eatWhile(tests.symbol);\n\n        return \"error\";\n      },\n\n      indent: function (state) {\n        if (state.pathStack == null) return state.indentation;\n        return state.pathStack.indent;\n      },\n\n      closeBrackets: {pairs: \"()[]{}\\\"\\\"\"},\n      lineComment: \";\"\n    };\n  });\n});\n\n};"],
"names":["shadow$provide","global","require","module","exports","mod","define","amd","CodeMirror","defineMode","options","pushStack","state","stack","prev","pathStack","mode","popStack","readNumber","ch","stream","eat","eatWhile","tests","hex","digit","test","peek","sign","next","exponent","readSymbol","symbol","ATOM","readJoin","indent","nextIndent","BRACKET","readIdent","readParamExp","column","current","length","atomOrComp","pathomIndex","string","start","type","end","words","pathomCM","completions","cljsDeref","token","key_has_children_QMARK_","ATOM_COMP","digit_or_colon","keyword_char","block_indent","com","wsscode","pathom","viz","codemirror","startState","indentation","sol","eatSpace","escaped","STRING","key","ATOM_IDENT","NUMBER","VAR","closeBrackets","pairs","lineComment"]
}
