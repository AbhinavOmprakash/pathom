{
"version":3,
"file":"module$node_modules$graphql_language_service_parser$dist$onlineParser.js",
"lineCount":9,
"mappings":"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",
"sources":["node_modules/graphql-language-service-parser/dist/onlineParser.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql_language_service_parser$dist$onlineParser\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**\n                                                                                                                                                                                                                                                                   *  Copyright (c) Facebook, Inc.\n                                                                                                                                                                                                                                                                   *  All rights reserved.\n                                                                                                                                                                                                                                                                   *\n                                                                                                                                                                                                                                                                   *  This source code is licensed under the license found in the\n                                                                                                                                                                                                                                                                   *  LICENSE file in the root directory of this source tree.\n                                                                                                                                                                                                                                                                   *\n                                                                                                                                                                                                                                                                   *  \n                                                                                                                                                                                                                                                                   */\n\n/**\n * Builds an online immutable parser, designed to be used as part of a syntax\n * highlighting and code intelligence tools.\n *\n * Options:\n *\n *     eatWhitespace: (\n *       stream: Stream | CodeMirror.StringStream | CharacterStream\n *     ) => boolean\n *       Use CodeMirror API.\n *\n *     LexRules: { [name: string]: RegExp }, Includes `Punctuation`, `Comment`.\n *\n *     ParseRules: { [name: string]: Array<Rule> }, Includes `Document`.\n *\n *     editorConfig: { [name: string]: any }, Provides an editor-specific\n *       configurations set.\n *\n */\n\nexports.default = onlineParser;\n\nvar _Rules = require('./Rules');\n\nfunction onlineParser() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    eatWhitespace: function eatWhitespace(stream) {\n      return stream.eatWhile(_Rules.isIgnored);\n    },\n    lexRules: _Rules.LexRules,\n    parseRules: _Rules.ParseRules,\n    editorConfig: {}\n  };\n\n  return {\n    startState: function startState() {\n      var initialState = {\n        level: 0,\n        step: 0,\n        name: null,\n        kind: null,\n        type: null,\n        rule: null,\n        needsSeperator: false,\n        prevState: null\n      };\n      pushRule(options.parseRules, initialState, 'Document');\n      return initialState;\n    },\n    token: function token(stream, state) {\n      return getToken(stream, state, options);\n    }\n  };\n}\n\nfunction getToken(stream, state, options) {\n  var lexRules = options.lexRules,\n      parseRules = options.parseRules,\n      eatWhitespace = options.eatWhitespace,\n      editorConfig = options.editorConfig;\n  // Restore state after an empty-rule.\n\n  if (state.rule && state.rule.length === 0) {\n    popRule(state);\n  } else if (state.needsAdvance) {\n    state.needsAdvance = false;\n    advanceRule(state, true);\n  }\n\n  // Remember initial indentation\n  if (stream.sol()) {\n    var tabSize = editorConfig && editorConfig.tabSize || 2;\n    state.indentLevel = Math.floor(stream.indentation() / tabSize);\n  }\n\n  // Consume spaces and ignored characters\n  if (eatWhitespace(stream)) {\n    return 'ws';\n  }\n\n  // Get a matched token from the stream, using lex\n  var token = lex(lexRules, stream);\n\n  // If there's no matching token, skip ahead.\n  if (!token) {\n    stream.match(/\\S+/);\n    pushRule(SpecialParseRules, state, 'Invalid');\n    return 'invalidchar';\n  }\n\n  // If the next token is a Comment, insert a Comment parsing rule.\n  if (token.kind === 'Comment') {\n    pushRule(SpecialParseRules, state, 'Comment');\n    return 'comment';\n  }\n\n  // Save state before continuing.\n  var backupState = assign({}, state);\n\n  // Handle changes in expected indentation level\n  if (token.kind === 'Punctuation') {\n    if (/^[{([]/.test(token.value)) {\n      // Push on the stack of levels one level deeper than the current level.\n      state.levels = (state.levels || []).concat(state.indentLevel + 1);\n    } else if (/^[})\\]]/.test(token.value)) {\n      // Pop from the stack of levels.\n      // If the top of the stack is lower than the current level, lower the\n      // current level to match.\n      var levels = state.levels = (state.levels || []).slice(0, -1);\n      if (state.indentLevel) {\n        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n          state.indentLevel = levels[levels.length - 1];\n        }\n      }\n    }\n  }\n\n  while (state.rule) {\n    // If this is a forking rule, determine what rule to use based on\n    var expected = typeof state.rule === 'function' ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];\n\n    // Seperator between list elements if necessary.\n    if (state.needsSeperator) {\n      expected = expected && expected.separator;\n    }\n\n    if (expected) {\n      // Un-wrap optional/list parseRules.\n      if (expected.ofRule) {\n        expected = expected.ofRule;\n      }\n\n      // A string represents a Rule\n      if (typeof expected === 'string') {\n        pushRule(parseRules, state, expected);\n        continue;\n      }\n\n      // Otherwise, match a Terminal.\n      if (expected.match && expected.match(token)) {\n        if (expected.update) {\n          expected.update(state, token);\n        }\n\n        // If this token was a punctuator, advance the parse rule, otherwise\n        // mark the state to be advanced before the next token. This ensures\n        // that tokens which can be appended to keep the appropriate state.\n        if (token.kind === 'Punctuation') {\n          advanceRule(state, true);\n        } else {\n          state.needsAdvance = true;\n        }\n\n        return expected.style;\n      }\n    }\n    unsuccessful(state);\n  }\n\n  // The parser does not know how to interpret this token, do not affect state.\n  assign(state, backupState);\n  pushRule(SpecialParseRules, state, 'Invalid');\n  return 'invalidchar';\n}\n\n// Utility function to assign from object to another object.\nfunction assign(to, from) {\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    to[keys[i]] = from[keys[i]];\n  }\n  return to;\n}\n\n// A special rule set for parsing comment tokens.\nvar SpecialParseRules = {\n  Invalid: [],\n  Comment: []\n};\n\n// Push a new rule onto the state.\nfunction pushRule(rules, state, ruleKind) {\n  if (!rules[ruleKind]) {\n    throw new TypeError('Unknown rule: ' + ruleKind);\n  }\n  state.prevState = _extends({}, state);\n  state.kind = ruleKind;\n  state.name = null;\n  state.type = null;\n  state.rule = rules[ruleKind];\n  state.step = 0;\n  state.needsSeperator = false;\n}\n\n// Pop the current rule from the state.\nfunction popRule(state) {\n  // Check if there's anything to pop\n  if (!state.prevState) {\n    return;\n  }\n  state.kind = state.prevState.kind;\n  state.name = state.prevState.name;\n  state.type = state.prevState.type;\n  state.rule = state.prevState.rule;\n  state.step = state.prevState.step;\n  state.needsSeperator = state.prevState.needsSeperator;\n  state.prevState = state.prevState.prevState;\n}\n\n// Advance the step of the current rule.\nfunction advanceRule(state, successful) {\n  // If this is advancing successfully and the current state is a list, give\n  // it an opportunity to repeat itself.\n  if (isList(state)) {\n    if (state.rule && state.rule[state.step].separator) {\n      var separator = state.rule[state.step].separator;\n      state.needsSeperator = !state.needsSeperator;\n      // If the separator was optional, then give it an opportunity to repeat.\n      if (!state.needsSeperator && separator.ofRule) {\n        return;\n      }\n    }\n    // If this was a successful list parse, then allow it to repeat itself.\n    if (successful) {\n      return;\n    }\n  }\n\n  // Advance the step in the rule. If the rule is completed, pop\n  // the rule and advance the parent rule as well (recursively).\n  state.needsSeperator = false;\n  state.step++;\n\n  // While the current rule is completed.\n  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n    popRule(state);\n\n    if (state.rule) {\n      // Do not advance a List step so it has the opportunity to repeat itself.\n      if (isList(state)) {\n        if (state.rule && state.rule[state.step].separator) {\n          state.needsSeperator = !state.needsSeperator;\n        }\n      } else {\n        state.needsSeperator = false;\n        state.step++;\n      }\n    }\n  }\n}\n\nfunction isList(state) {\n  return Array.isArray(state.rule) && typeof state.rule[state.step] !== 'string' && state.rule[state.step].isList;\n}\n\n// Unwind the state after an unsuccessful match.\nfunction unsuccessful(state) {\n  // Fall back to the parent rule until you get to an optional or list rule or\n  // until the entire stack of rules is empty.\n  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n    popRule(state);\n  }\n\n  // If there is still a rule, it must be an optional or list rule.\n  // Consider this rule a success so that we may move past it.\n  if (state.rule) {\n    advanceRule(state, false);\n  }\n}\n\n// Given a stream, returns a { kind, value } pair, or null.\nfunction lex(lexRules, stream) {\n  var kinds = Object.keys(lexRules);\n  for (var i = 0; i < kinds.length; i++) {\n    var match = stream.match(lexRules[kinds[i]]);\n    if (match && match instanceof Array) {\n      return { kind: kinds[i], value: match[0] };\n    }\n  }\n}\n};"],
"names":["shadow$provide","global","require","module","exports","getToken","stream","state","options","lexRules","parseRules","eatWhitespace","editorConfig","rule","length","popRule","needsAdvance","advanceRule","sol","tabSize","indentLevel","Math","floor","indentation","kinds","Object","keys","i","match","Array","kind","value","token","pushRule","SpecialParseRules","backupState","assign","test","levels","concat","slice","expected","step","needsSeperator","separator","ofRule","update","style","isArray","to","from","rules","ruleKind","TypeError","prevState","_extends","name","type","successful","isList","defineProperty","target","arguments","source","key","prototype","hasOwnProperty","call","default","onlineParser","undefined","eatWhile","_Rules","isIgnored","LexRules","ParseRules","startState","initialState","level","Invalid","Comment"]
}
