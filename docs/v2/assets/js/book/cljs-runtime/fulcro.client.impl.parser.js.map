{"version":3,"sources":["fulcro/client/impl/parser.cljc"],"mappings":"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","names":["fulcro.client.impl.parser/mark-meta","source","target","G__60014","cljs.core/meta","cljs.core.assoc","fulcro.client.impl.parser/symbol->ast","k","fulcro.client.impl.parser/keyword->ast","p__60028","vec__60029","cljs.core.nth","fulcro.client.impl.parser/union-entry->ast","v","component","cljs.core.merge","cljs.core.into","cljs.core.map","fulcro.client.impl.parser/expr->ast","fulcro.client.impl.parser/union->ast","m","p__60043","vec__60044","fulcro.client.impl.parser/call->ast","f","args","call","cljs.core._EQ_","or__4131__auto__","ast","cljs.core.update_in","cljs.core/merge","G__60047","cljs.core/Symbol","fulcro.client.impl.parser/query->ast","query","fulcro.client.impl.parser/join->ast","join","vec__60053","query-root?","cljs.core/first","type","cljs.core/vector?","cljs.core/map?","cljs.core.ex_info","p__60065","vec__60066","fulcro.client.impl.parser/ident->ast","id","ref","x","cljs.core/Keyword","cljs.core/seq?","fulcro.client.impl.parser/wrap-expr","root?","expr","cljs.core/with-meta","G__60072","cljs.core/List","fulcro.client.impl.parser/parameterize","params","cljs.core/empty?","var_args","G__60077","fulcro.client.impl.parser/ast->expr","js/Error","p__60078","map__60079","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","cljs.core.get","fulcro.client.impl.parser.ast__GT_expr","ast-meta","unparse?","G__60081","p1__60073#","cljs.core.vary_meta","cljs.core/assoc","map__60082","key","query-root","and__4120__auto__","cljs.core.not_EQ_","cljs.core.dissoc","map__60084","children","query-meta","cljs.core/count","G__60086","p__60087","map__60088","union-key","G__60090","p1__60074#","G__60091","p1__60075#","G__60097","fulcro.client.impl.parser/path-meta","data","path","fulcro.client.impl.parser.path_meta","union-expr","G__60098","cljs.core/native-satisfies?","cljs.core/IWithMeta","cljs.core/sequential?","cljs.core.map_indexed","idx","cljs.core.conj","joins","cljs.core/seq","ret","fulcro.util/join?","fulcro.util/ident?","cljs.core/next","vec__60100","G__60103","G__60104","cljs.core/PersistentHashMap","sel","fulcro.util/join-entry","union-entry","fulcro.util/union?","fulcro.util/recursion?","G__60105","fulcro.util/unique-ident?","G__60108","cljs.core/contains?","G__60109","dispatch-key","cljs.core.comp","branches","cljs.core/vals","props","cljs.core/keys","cljs.core.reduce","q","query-props","cljs.core/set","cljs.core/reduced","clojure.set/subset?","fulcro.client.impl.parser/rethrow?","cljs.core/ExceptionInfo","cljs.core/ex-data","fulcro.client.impl.parser/substitute-root-path-for-ident","data-tree","replacement-root-path","map__60114","join-ast-node","subquery","real-data-tree-of-interest","result","p__60122","map__60123","fulcro.client.impl.parser/parser","read","mutate","config","env","fulcro$client$impl$parser$parser_$_self","map__60125","G__60126","self","map__60142","query'","G__60146","call?","res","G__60147","ast'","G__60149","p1__60118#","p2__60119#","cljs.core/update","error","cljs.core.atom","mut-ret","e60154","cljs.core/reset!","fexpr__60156","e","value","G__60157","cljs.core/deref","G__60158","cljs.core/assoc-in","p1__60120#","p2__60121#","G__60159","step","fulcro.client.impl.parser/dispatch","_"],"sourcesContent":["(ns\n  ^{:doc \"\n   Generic query expression parsing and AST manipulation.\n\n   QUERY EXPRESSIONS\n\n   Query expressions are a variation on Datomic Pull Syntax\n   http://docs.datomic.com/pull.html more suitable for generic client/server\n   state transfer. It's important to note the query expression syntax is\n   *not* a strict superset of Datomic Pull.\n\n   A query expression is composed of EDN values. The grammar for query\n   expressions follows:\n\n   QueryRoot      := EdnVector(QueryExpr*)\n   PlainQueryExpr := (EdnKeyword | IdentExpr | JoinExpr)\n   QueryExpr      := (PlainQueryExpr | ParamExpr)\n   IdentExpr      := EdnVector2(Keyword, EdnValue)\n   ParamExpr      := EdnList2(PlainQueryExpr | EdnSymbol, ParamMapExpr)\n   ParamMapExpr   := EdnMap(Keyword, EdnValue)\n   JoinExpr       := EdnMap((Keyword | IdentExpr), (QueryRoot | UnionExpr | RecurExpr))\n   UnionExpr      := EdnMap(Keyword, QueryRoot)\n   RecurExpr      := ('... | Integer)\n\n   Note most of the api expects a QueryRoot not a QueryExpr.\n\n   QUERY EXPRESSION AST FORMAT\n\n   Given a QueryExpr you can get the AST via om.next.impl.parser/expr->ast.\n   The following keys can appear in the AST representation:\n\n   {:type         (:prop | :join | :call | :root | :union | :union-entry)\n    :key          (EdnKeyword | EdnSymbol | IdentExpr)\n    :dispatch-key (EdnKeyword | EdnSymbol)\n    :union-key    EdnKeyword\n    :query        (QueryRoot | RecurExpr)\n    :params       ParamMapExpr\n    :children     EdnVector(AST)\n    :component    Object\n    :target       EdnKeyword}\n\n   :query and :params may or may not appear. :type :call is only for\n   mutations.\"}\n  fulcro.client.impl.parser\n  (:require [clojure.set :as set]\n            [fulcro.logging :as log]\n            [fulcro.util :as util]))\n\n(declare expr->ast)\n\n(defn- mark-meta [source target]\n  (cond-> target\n    (meta source) (assoc :meta (meta source))))\n\n(defn symbol->ast [k]\n  {:dispatch-key k\n   :key          k})\n\n(defn keyword->ast [k]\n  {:type         :prop\n   :dispatch-key k\n   :key          k})\n\n(defn union-entry->ast [[k v]]\n  (let [component (-> v meta :component)]\n    (merge\n      {:type      :union-entry\n       :union-key k\n       :query     v\n       :children  (into [] (map expr->ast) v)}\n      (when-not (nil? component)\n        {:component component}))))\n\n(defn union->ast [m]\n  {:type     :union\n   :query    m\n   :children (into [] (map union-entry->ast) m)})\n\n(defn call->ast [[f args :as call]]\n  (if (= 'quote f)\n    (assoc (expr->ast args) :target (or (-> call meta :target) :remote))\n    (let [ast (update-in (expr->ast f) [:params] merge (or args {}))]\n      (cond-> (mark-meta call ast)\n        (symbol? (:dispatch-key ast)) (assoc :type :call)))))\n\n(defn query->ast\n  \"Convert a query to its AST representation.\"\n  [query]\n  (let [component (-> query meta :component)]\n    (merge\n      (mark-meta query\n        {:type     :root\n         :children (into [] (map expr->ast) query)})\n      (when-not (nil? component)\n        {:component component}))))\n\n(defn join->ast [join]\n  (let [query-root? (-> join meta :query-root)\n        [k v] (first join)\n        ast         (expr->ast k)\n        type        (if (= :call (:type ast)) :call :join)\n        component   (-> v meta :component)]\n    (merge ast\n      (mark-meta join {:type type :query v})\n      (when-not (nil? component)\n        {:component component})\n      (when query-root?\n        {:query-root true})\n      (when-not (or (number? v) (= '... v))\n        (cond\n          (vector? v) {:children (into [] (map expr->ast) v)}\n          (map? v) {:children [(union->ast v)]}\n          :else (throw\n                  (ex-info (str \"Invalid join, \" join)\n                    {:type :error/invalid-join})))))))\n\n(defn ident->ast [[k id :as ref]]\n  {:type         :prop\n   :dispatch-key k\n   :key          ref})\n\n(defn expr->ast\n  \"Given a query expression convert it into an AST.\"\n  [x]\n  (cond\n    (symbol? x) (symbol->ast x)\n    (keyword? x) (keyword->ast x)\n    (map? x) (join->ast x)\n    (vector? x) (ident->ast x)\n    (seq? x) (call->ast x)\n    :else (throw\n            (ex-info (str \"Invalid expression \" x)\n              {:type :error/invalid-expression}))))\n\n(defn wrap-expr [root? expr]\n  (if root?\n    (with-meta\n      (cond-> expr (keyword? expr) list)\n      {:query-root true})\n    expr))\n\n(defn parameterize [expr params]\n  (if-not (empty? params)\n    (list expr params)\n    (list expr)))\n\n(defn ast->expr\n  \"Given a query expression AST convert it back into a query expression.\"\n  ([ast]\n   (ast->expr ast false))\n  ([{:keys [type component] ast-meta :meta :as ast} unparse?]\n   (if (= :root type)\n     (cond-> (into (with-meta [] ast-meta) (map #(ast->expr % unparse?)) (:children ast))\n       (not (nil? component)) (vary-meta assoc :component component))\n     (let [{:keys [key query query-root params]} ast]\n       (wrap-expr query-root\n         (if (and params (not= :call type))\n           (let [expr (ast->expr (dissoc ast :params) unparse?)]\n             (parameterize expr params))\n           (let [key (if (= :call type) (parameterize key params) key)]\n             (if (or (= :join type)\n                   (and (= :call type) (:children ast)))\n               (if (and (not= '... query) (not (number? query))\n                     (or (true? unparse?)\n                       (= :call type)))\n                 (let [{:keys [children]} ast\n                       query-meta (meta query)]\n                   (if (and (== 1 (count children))\n                         (= :union (:type (first children)))) ;; UNION\n                     (with-meta\n                       {key (into (cond-> (with-meta {} ast-meta)\n                                    component (vary-meta assoc :component component))\n                              (map (fn [{:keys [union-key children component]}]\n                                     [union-key\n                                      (cond-> (into [] (map #(ast->expr % unparse?)) children)\n                                        (not (nil? component)) (vary-meta assoc :component component))]))\n                              (:children (first children)))}\n                       ast-meta)\n                     (with-meta\n                       {key (cond-> (into (with-meta [] query-meta) (map #(ast->expr % unparse?)) children)\n                              (not (nil? component)) (vary-meta assoc :component component))}\n                       ast-meta)))\n                 (with-meta {key query} ast-meta))\n               key))))))))\n\n(defn path-meta\n  \"Add path metadata to a data structure. data is the data to be worked on.\n   path is the current path into the data. query is the query used to\n   walk the data. union-expr tracks the last seen union query to be used\n   when it finds a recursive union.\"\n  ([data path query]\n   (path-meta data path query nil))\n  ([data path query union-expr]\n   (cond\n     (nil? query)\n     (cond-> data\n       #?(:clj  (instance? clojure.lang.IObj data)\n          :cljs (satisfies? IWithMeta data))\n       (vary-meta assoc ::data-path path))\n\n     (sequential? data)\n     (-> (into []\n           (map-indexed\n             (fn [idx v]\n               (path-meta v (conj path idx) query union-expr))) data)\n       (vary-meta assoc ::data-path path))\n\n     (vector? query)\n     (loop [joins (seq query) ret data]\n       (if-not (nil? joins)\n         (let [join (first joins)]\n           (if-not (or (util/join? join)\n                     (util/ident? join)\n                     (and (seq? join)\n                       (util/ident? (first join))))\n             (recur (next joins) ret)\n             (let [join        (cond-> join (seq? join) first)\n                   join        (cond-> join (util/ident? join) (hash-map '[*]))\n                   [key sel] (util/join-entry join)\n                   union-entry (if (util/union? join) sel union-expr)\n                   sel         (if (util/recursion? sel)\n                                 (if-not (nil? union-expr)\n                                   union-entry\n                                   query)\n                                 sel)\n                   key         (cond-> key (util/unique-ident? key) first)\n                   v           (get ret key)]\n               (recur (next joins)\n                 (cond-> ret\n                   (and (map? ret) (contains? ret key))\n                   (assoc key\n                          (path-meta v (conj path key) sel union-entry)))))))\n         (cond-> ret\n           #?(:clj  (instance? clojure.lang.IObj ret)\n              :cljs (satisfies? IWithMeta ret))\n           (vary-meta assoc ::data-path path))))\n\n     :else\n     ;; UNION\n     (if (map? data)\n       (let [dispatch-key (comp :dispatch-key expr->ast)\n             branches     (vals query)\n             props        (map dispatch-key (keys data))\n             query        (reduce (fn [ret q]\n                                    (let [query-props (into #{} (map dispatch-key) q)\n                                          props       (set props)]\n                                      (cond\n                                        (= (set props)\n                                          (set query-props)) (reduced q)\n                                        (set/subset? props query-props) q\n                                        :else ret)))\n                            nil branches)]\n         (path-meta data path query union-expr))\n       data))))\n\n(defn rethrow? [x]\n  (and (instance? #?(:clj clojure.lang.ExceptionInfo :cljs ExceptionInfo) x)\n    (= :fulcro.client.primitives/abort (-> x ex-data :type))))\n\n(defn substitute-root-path-for-ident\n  \"Given the result (and query) of an ident-based query like:\n\n  [{[:TABLE :ID] (get-query C)}]\n\n  a query response data tree:\n\n  { [:TABLE :ID] { ...props for C...} }\n\n  and a replacement-root-path such as [:ROOT/subcomponent :subcomponent/items 0],\n  adds path metadata to the val (props for C) of that data tree as-if it had been\n  queried from the UI root (replacement-root-path). E.g. the path metadata on the val (props of C) will\n  START at replacement-root-path.\"\n  [data-tree replacement-root-path query]\n  (let [join-ast-node              (-> (query->ast query) :children first)\n        {subquery :query :keys [key]} join-ast-node\n        real-data-tree-of-interest (get data-tree key)\n        result                     (path-meta real-data-tree-of-interest replacement-root-path subquery)]\n    {key result}))\n\n(defn parser\n  \"Given a :read and/or :mutate function return a parser. Refer to fulcro.client.primitives/parser\n   for top level documentation.\"\n  [{:keys [read mutate] :as config}]\n  (fn self\n    ([env query] (self env query nil))\n    ([env query target]\n     (let [target (or target (:target env))\n           {:keys [replacement-root-path path] :as env} (cond-> (assoc env :parser self :target target :query-root :fulcro.client.primitives/root)\n                                                          (not (contains? env :path)) (assoc :path []))]\n       (letfn [(step [ret expr]\n                 (let [{query' :query :keys [key dispatch-key params] :as ast} (expr->ast expr)\n                       env   (cond-> (merge env {:ast ast :query query'})\n                               (nil? query') (dissoc :query)\n                               (= '... query') (assoc :query query)\n                               (vector? key) (assoc :query-root key))\n                       type  (:type ast)\n                       call? (= :call type)\n                       res   (case type\n                               :call\n                               (do\n                                 (assert mutate \"Parse mutation attempted but no :mutate function supplied\")\n                                 (mutate env dispatch-key params))\n                               (:prop :join :union)\n                               (do\n                                 (assert read \"Parse read attempted but no :read function supplied\")\n                                 (read env dispatch-key params))\n                               nil)]\n                   (if-not (nil? target)\n                     (let [ast' (get res target)]\n                       (cond-> ret\n                         (true? ast') (conj expr)\n                         (map? ast') (conj (ast->expr ast'))\n                         (seq (:refresh res)) (vary-meta update :fulcro.client.primitives/refresh #(into (or %1 #{}) %2) (:refresh res))))\n                     (if-not (or call? (nil? (:target ast)) (contains? res :value))\n                       ret\n                       (let [error   (atom nil)\n                             mut-ret (atom nil)]\n                         (when (and call? (not (nil? (:action res))))\n                           (try\n                             (reset! mut-ret ((:action res)))\n                             (catch #?(:clj Throwable :cljs :default) e\n                               (if (rethrow? e)\n                                 (throw e)\n                                 (reset! error e)))))\n                         (let [value (:value res)]\n                           (when call?\n                             (assert (or (nil? value) (map? value))\n                               ; FIXME: This no longer applies, but should be editing in a testing context.\n                               (str dispatch-key \" mutation :value must be nil or a map with structure {:refresh [...]}\")))\n                           (cond-> ret\n                             (not (nil? value)) (assoc (cond-> key\n                                                         (util/unique-ident? key)\n                                                         first)\n                                                       value)\n                             @mut-ret (assoc-in [key :result] @mut-ret)\n                             (seq (:refresh res)) (vary-meta update :fulcro.client.primitives/refresh #(into (or %1 #{}) %2) (:refresh res))\n                             @error (assoc key {:fulcro.client.primitives/error @error}))))))))]\n         (cond->\n           (reduce step (if (nil? target) {} []) query)\n           (nil? target) (path-meta path query) ;; FIXME: Don't add meta twice...overhead\n           replacement-root-path (substitute-root-path-for-ident replacement-root-path query)))))))\n\n(defn dispatch [_ k _] k)\n\n"]}