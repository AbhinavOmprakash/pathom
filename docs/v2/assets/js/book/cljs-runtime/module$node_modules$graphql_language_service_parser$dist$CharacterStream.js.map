{
"version":3,
"file":"module$node_modules$graphql_language_service_parser$dist$CharacterStream.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/graphql-language-service-parser/dist/CharacterStream.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql_language_service_parser$dist$CharacterStream\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar CharacterStream = function () {\n  function CharacterStream(sourceText) {\n    var _this = this;\n\n    _classCallCheck(this, CharacterStream);\n\n    this.getStartOfToken = function () {\n      return _this._start;\n    };\n\n    this.getCurrentPosition = function () {\n      return _this._pos;\n    };\n\n    this.eol = function () {\n      return _this._sourceText.length === _this._pos;\n    };\n\n    this.sol = function () {\n      return _this._pos === 0;\n    };\n\n    this.peek = function () {\n      return _this._sourceText.charAt(_this._pos) ? _this._sourceText.charAt(_this._pos) : null;\n    };\n\n    this.next = function () {\n      var char = _this._sourceText.charAt(_this._pos);\n      _this._pos++;\n      return char;\n    };\n\n    this.eat = function (pattern) {\n      var isMatched = _this._testNextCharacter(pattern);\n      if (isMatched) {\n        _this._start = _this._pos;\n        _this._pos++;\n        return _this._sourceText.charAt(_this._pos - 1);\n      }\n      return undefined;\n    };\n\n    this.eatWhile = function (match) {\n      var isMatched = _this._testNextCharacter(match);\n      var didEat = false;\n\n      // If a match, treat the total upcoming matches as one token\n      if (isMatched) {\n        didEat = isMatched;\n        _this._start = _this._pos;\n      }\n\n      while (isMatched) {\n        _this._pos++;\n        isMatched = _this._testNextCharacter(match);\n        didEat = true;\n      }\n\n      return didEat;\n    };\n\n    this.eatSpace = function () {\n      return _this.eatWhile(/[\\s\\u00a0]/);\n    };\n\n    this.skipToEnd = function () {\n      _this._pos = _this._sourceText.length;\n    };\n\n    this.skipTo = function (position) {\n      _this._pos = position;\n    };\n\n    this.match = function (pattern) {\n      var consume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var caseFold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var token = null;\n      var match = null;\n\n      if (typeof pattern === 'string') {\n        var regex = new RegExp(pattern, caseFold ? 'i' : 'g');\n        match = regex.test(_this._sourceText.substr(_this._pos, pattern.length));\n        token = pattern;\n      } else if (pattern instanceof RegExp) {\n        match = _this._sourceText.slice(_this._pos).match(pattern);\n        token = match && match[0];\n      }\n\n      if (match != null) {\n        if (typeof pattern === 'string' || match instanceof Array &&\n        // String.match returns 'index' property, which flow fails to detect\n        // for some reason. The below is a workaround, but an easier solution\n        // is just checking if `match.index === 0`\n        _this._sourceText.startsWith(match[0], _this._pos)) {\n          if (consume) {\n            _this._start = _this._pos;\n            if (token && token.length) {\n              _this._pos += token.length;\n            }\n          }\n          return match;\n        }\n      }\n\n      // No match available.\n      return false;\n    };\n\n    this.backUp = function (num) {\n      _this._pos -= num;\n    };\n\n    this.column = function () {\n      return _this._pos;\n    };\n\n    this.indentation = function () {\n      var match = _this._sourceText.match(/\\s*/);\n      var indent = 0;\n      if (match && match.length === 0) {\n        var whitespaces = match[0];\n        var pos = 0;\n        while (whitespaces.length > pos) {\n          if (whitespaces.charCodeAt(pos) === 9) {\n            indent += 2;\n          } else {\n            indent++;\n          }\n          pos++;\n        }\n      }\n\n      return indent;\n    };\n\n    this.current = function () {\n      return _this._sourceText.slice(_this._start, _this._pos);\n    };\n\n    this._start = 0;\n    this._pos = 0;\n    this._sourceText = sourceText;\n  }\n\n  CharacterStream.prototype._testNextCharacter = function _testNextCharacter(pattern) {\n    var character = this._sourceText.charAt(this._pos);\n    var isMatched = false;\n    if (typeof pattern === 'string') {\n      isMatched = character === pattern;\n    } else {\n      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);\n    }\n    return isMatched;\n  };\n\n  return CharacterStream;\n}(); /**\n      *  Copyright (c) Facebook, Inc.\n      *  All rights reserved.\n      *\n      *  This source code is licensed under the license found in the\n      *  LICENSE file in the root directory of this source tree.\n      *\n      *  \n      */\n\n/**\n * CharacterStream implements a stream of character tokens given a source text.\n * The API design follows that of CodeMirror.StringStream.\n *\n * Required:\n *\n *      sourceText: (string), A raw GraphQL source text. Works best if a line\n *        is supplied.\n *\n */\n\nexports.default = CharacterStream;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","CharacterStream","sourceText","_this","instance","TypeError","getStartOfToken","this.getStartOfToken","_start","getCurrentPosition","this.getCurrentPosition","_pos","eol","this.eol","_sourceText","length","sol","this.sol","peek","this.peek","charAt","next","this.next","char","eat","this.eat","pattern","_testNextCharacter","isMatched","eatWhile","this.eatWhile","match","didEat","eatSpace","this.eatSpace","skipToEnd","this.skipToEnd","skipTo","this.skipTo","position","this.match","consume","arguments","undefined","caseFold","token","test","regex","RegExp","substr","slice","Array","startsWith","backUp","this.backUp","num","column","this.column","indentation","this.indentation","indent","whitespaces","pos","charCodeAt","current","this.current","prototype","CharacterStream.prototype._testNextCharacter","character","default"]
}
