{"version":3,"sources":["fulcro/client/util.cljc"],"mappings":";;;;;;;;;;;;;;AAkBA,AAAA;;;;;;AAAA,AAAAA,AAAME;AAAN,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAMD,AAKFE,AAAWC;AALf,AAMG,AAACC,AAAaF,AAAWC;;AACzB,AAACE,AAAsBH;;;AAP1B,AAAA,AAAA,AAAMF,AAQFE;AARJ,AASG,AAACI,AAAwBJ;;;AAT5B,AAAA,AAAA,AAAMF;;AAAN,AAWA;;;;AAAA,AAAMO,AAGHC,AAAYC;AAHf,AAAA,AAISD;AAJT;AAAA,AAAA,AAAA,AAAAP,AAAA;;;AAAA,AAIqBQ;AAJrB;AAAA,AAAA,AAAA,AAAAR,AAAA;;;AAKE,AAAM,AAACS,AAAE,AAACC,AAAgBF,AAAgBD;AAA1C,AACEC;;AADF;;;AAGF;;;;AAAA,AAAMG,AAGHJ,AAAYK;AAHf,AAIE,AAAA,AAAAC,AAACC;AAAD,AAAO,AAAAD,AAACP,AAAgBC;AAAeK;;AAEzC,AAAA;;;AAAA,AAAAf,AAAMmB;AAAN,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAhB,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAMgB,AAEFC;AAFJ,AAEU,AAAA,AAACC,AAAiBD;;;AAF5B,AAAA,AAAA,AAAMD,AAGFC,AAAKE;AAHT,AAIY,AAACC,AAAQ,AAACC,AAAsBF,AAAMF;;;AAJlD,AAAA,AAAA,AAAMD;;AAAN,AAUA,AAAA;;;AAAA,AAAAnB,AAAM0B;AAAN,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAvB,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAMuB,AAEFC;AAFJ,AAES,AAAA,AAACC,AAAiBD;;;AAF3B,AAAA,AAAA,AAAMD,AAGFC,AAAIL;AAHR,AAIY,AAACO,AAAO,AAACC,AAAYR,AAAMK;;;AAJvC,AAAA,AAAA,AAAMD;;AAAN,AAOA;;;AAAA,AAAMK,AAEHJ;AAFH,AAIW,AAAMK,AAAM,AAACC,AAA4B,AAACC,AAAQP;AAAlD,AACE,AAACQ,AAAiB,AAAA,AAACC,AAAY,AAACC,AAAIC,AAAKN;;AAEtD,AAAA,AAAMO,AACHZ;AADH,AAGW,AAAMK,AAAM,AAACK,AAAIG,AAAU,AAACC,AAAI,AAACC,AAAiBf;AAAlD,AACE,AAACgB,AAA4B,AAACT,AAAQF;;AAEnD;;;AAAA,AAAMY,AAEHC;AAFH,AAGM,AAAA,AAAAC,AAACC,AAAoF,AAACI;AAAtF,AAAuB,AAAI,AAAAL,AAACE;AAAQ,AAAAF,AAAA,AAACG;;AAAdH;;AAAmC,AAACI,AAAkBL,AAAQ;;AAE3F;;;AAAKO,AAAsFC","names":["var_args","G__66004","fulcro.client.util/force-render","js/Error","reconciler","keywords","fulcro.client.impl.protocols/queue!","fulcro.client.primitives/schedule-render!","fulcro.client.primitives/force-root-render!","fulcro.client.util/react-instance?","react-class","react-instance","cljs.core._EQ_","fulcro.client.primitives/react-type","fulcro.client.util/first-node","sequence-of-react-instances","p1__66025#","cljs.core/some","G__66035","fulcro.client.util/transit-clj->str","coll","fulcro.client.util.transit_clj__GT_str","opts","cognitect.transit/write","fulcro.transit.writer","G__66043","fulcro.client.util/transit-str->clj","str","fulcro.client.util.transit_str__GT_clj","cognitect.transit/read","fulcro.client.primitives.reader","fulcro.client.util/base64-encode","bytes","goog.crypt/stringToUtf8ByteArray","cljs.core/clj->js","goog.crypt.base64/encodeString","clojure.string.join","cljs.core.map","cljs.core/char","fulcro.client.util/base64-decode","cljs.pprint/char-code","cljs.core/vec","goog.crypt.base64/decodeString","goog.crypt/utf8ByteArrayToString","fulcro.client.util/strip-parameters","query","p1__66062#","clojure.walk/prewalk","cljs.core/map?","cljs.core.dissoc","fulcro.client.impl.parser/query->ast","fulcro.client.impl.parser.ast__GT_expr","fulcro.client.util/integrate-ident","fulcro.client.primitives/integrate-ident"],"sourcesContent":["(ns fulcro.client.util\n  (:require\n    [clojure.spec.alpha :as s]\n    clojure.walk\n    [fulcro.client.primitives :as prim]\n    [fulcro.client.impl.protocols :as proto]\n    fulcro.transit\n    [fulcro.util :as util :refer [unique-key]]\n    [cognitect.transit :as t]\n    [fulcro.client.impl.parser :as parser]\n    [clojure.string :as str]\n    #?(:cljs [cljs.pprint :refer [char-code]])\n    #?(:cljs [goog.crypt :as crypt])\n    #?(:cljs [goog.crypt.base64 :as b64])\n    #?(:clj  [clojure.spec.gen.alpha :as sg]))\n  #?(:clj (:import [java.util Base64]\n                   [java.nio.charset StandardCharsets])))\n\n(defn force-render\n  \"Re-render components. If only a reconciler is supplied then it forces a full React DOM refresh.\n\n  If you supply an additional vector of keywords and idents then it will try to rerender only those components that mention\n  those things in their queries.\"\n  ([reconciler keywords]\n   (proto/queue! reconciler keywords)\n   (prim/schedule-render! reconciler))\n  ([reconciler]\n   (prim/force-root-render! reconciler)))\n\n(defn react-instance?\n  \"Returns the react-instance (which is logically true) iff the given react instance is an instance of the given react class.\n  Otherwise returns nil.\"\n  [react-class react-instance]\n  {:pre [react-class react-instance]}\n  (when (= (prim/react-type react-instance) react-class)\n    react-instance))\n\n(defn first-node\n  \"Finds (and returns) the first instance of the given React class (or nil if not found) in a sequence of instances. Useful\n  for finding a child of the correct type when nesting react components.\"\n  [react-class sequence-of-react-instances]\n  (some #(react-instance? react-class %) sequence-of-react-instances))\n\n(defn transit-clj->str\n  \"Use transit to encode clj data as a string. Useful for encoding initial app state from server-side rendering.\"\n  ([coll] (transit-clj->str coll {}))\n  ([coll opts]\n   #?(:cljs (t/write (fulcro.transit/writer opts) coll)\n      :clj\n      (with-open [out (java.io.ByteArrayOutputStream.)]\n        (t/write (fulcro.transit/writer out opts) coll)\n        (.toString out \"UTF-8\")))))\n\n(defn transit-str->clj\n  \"Use transit to decode a string into a clj data structure. Useful for decoding initial app state when starting from a server-side rendering.\"\n  ([str] (transit-str->clj str {}))\n  ([str opts]\n   #?(:cljs (t/read (prim/reader opts) str)\n      :clj  (t/read (prim/reader (java.io.ByteArrayInputStream. (.getBytes str \"UTF-8\")) opts)))))\n\n(defn base64-encode\n  \"Encode a string to UTF-8 and encode the result to base 64\"\n  [str]\n  #?(:clj  (.encodeToString (Base64/getEncoder) (.getBytes str \"UTF-8\"))\n     :cljs (let [bytes (crypt/stringToUtf8ByteArray (clj->js str))]  ;; First convert our JavaScript string from UCS-2/UTF-16 to UTF-8 bytes\n             (b64/encodeString (str/join \"\" (map char bytes))))))    ;; base64 encode that byte array to a string\n\n(defn base64-decode\n  [str]\n  #?(:clj  (String. (.decode (Base64/getDecoder) ^String str) (StandardCharsets/UTF_8))\n     :cljs (let [bytes (map char-code (vec (b64/decodeString str)))] ;; b64/decodeString produces essentially a byte array\n             (crypt/utf8ByteArrayToString (clj->js bytes)))))        ;; Convert the byte array to a valid JavaScript string (either UCS-2 or UTF-16)\n\n(defn strip-parameters\n  \"Removes parameters from the query, e.g. for PCI compliant logging.\"\n  [query]\n  (-> (clojure.walk/prewalk #(if (map? %) (dissoc % :params) %) (parser/query->ast query)) (parser/ast->expr true)))\n\n(def integrate-ident \"DEPRECATED: Now defined in fulcro.client.mutations/integrate-ident*\" prim/integrate-ident)\n"]}