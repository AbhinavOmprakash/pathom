{"version":3,"sources":["fulcro/client/impl/data_targeting.cljc"],"mappings":"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","names":["var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","fulcro.client.impl.data-targeting/multiple-targets","seq51189","self__4718__auto__","cljs.core/seq","targets","cljs.core/with-meta","cljs.core/vec","fulcro.client.impl.data-targeting/prepend-to","target","fulcro.client.impl.data-targeting/append-to","fulcro.client.impl.data-targeting/replace-at","fulcro.client.impl.data-targeting/replacement-target?","t","cljs.core/meta","cljs.core/boolean","fulcro.client.impl.data-targeting/prepend-target?","fulcro.client.impl.data-targeting/append-target?","fulcro.client.impl.data-targeting/multiple-targets?","fulcro.client.impl.data-targeting/special-target?","clojure.set.intersection","cljs.core/keys","cljs.core/set","fulcro.client.impl.data-targeting/integrate-ident","js/Error","seq51217","G__51218","cljs.core/first","cljs.core/next","G__51219","self__4717__auto__","state","ident","named-parameters","cljs.core/map?","actions","cljs.core.partition","cljs.core.reduce","p__51224","vec__51225","cljs.core.nth","command","data-path","already-has-ident-at-path?","p1__51214#","cljs.core/some","cljs.core._EQ_","cljs.core.get_in","G__51228","cljs.core/Keyword","cljs.core/vector?","p1__51215#","cljs.core.update_in","cljs.core.into","cljs.core/conj","path-to-vector","cljs.core/butlast","to-many?","index","cljs.core/last","vector","cljs.core/contains?","cljs.core/assoc-in","cljs.core.ex_info","G__51243","fulcro.client.impl.data-targeting/process-target","source-path","fulcro.client.impl.data_targeting.process_target","remove-ok?","item-to-place","fulcro.util/ident?","cljs.core.get","many-idents?","cljs.core/every?","G__51250","cljs.core.dissoc","G__51251","s","and__4120__auto__","target-has-many?","v","cljs.core.concat","G__51260","fulcro.client.impl.data_targeting.integrate_ident"],"sourcesContent":["(ns fulcro.client.impl.data-targeting\n  (:require [clojure.set :as set]\n            [fulcro.util :as util]))\n\n(defn multiple-targets [& targets]\n  (with-meta (vec targets) {::multiple-targets true}))\n\n(defn prepend-to [target]\n  (with-meta target {::prepend-target true}))\n\n(defn append-to [target]\n  (with-meta target {::append-target true}))\n\n(defn replace-at [target]\n  (with-meta target {::replace-target true}))\n\n(defn replacement-target? [t] (-> t meta ::replace-target boolean))\n(defn prepend-target? [t] (-> t meta ::prepend-target boolean))\n(defn append-target? [t] (-> t meta ::append-target boolean))\n(defn multiple-targets? [t] (-> t meta ::multiple-targets boolean))\n\n(defn special-target? [target]\n  (boolean (seq (set/intersection (-> target meta keys set) #{::replace-target ::append-target ::prepend-target ::multiple-targets}))))\n\n(defn integrate-ident\n  \"Integrate an ident into any number of places in the app state. This function is safe to use within mutation\n  implementations as a general helper function.\n\n  The named parameters can be specified any number of times. They are:\n\n  - append:  A vector (path) to a list in your app state where this new object's ident should be appended. Will not append\n  the ident if that ident is already in the list.\n  - prepend: A vector (path) to a list in your app state where this new object's ident should be prepended. Will not append\n  the ident if that ident is already in the list.\n  - replace: A vector (path) to a specific location in app-state where this object's ident should be placed. Can target a to-one or to-many.\n   If the target is a vector element then that element must already exist in the vector.\"\n  [state ident & named-parameters]\n  {:pre [(map? state)]}\n  (let [actions (partition 2 named-parameters)]\n    (reduce (fn [state [command data-path]]\n              (let [already-has-ident-at-path? (fn [data-path] (some #(= % ident) (get-in state data-path)))]\n                (case command\n                  :prepend (if (already-has-ident-at-path? data-path)\n                             state\n                             (do\n                               (assert (vector? (get-in state data-path)) (str \"Path \" data-path \" for prepend must target an app-state vector.\"))\n                               (update-in state data-path #(into [ident] %))))\n                  :append (if (already-has-ident-at-path? data-path)\n                            state\n                            (do\n                              (assert (vector? (get-in state data-path)) (str \"Path \" data-path \" for append must target an app-state vector.\"))\n                              (update-in state data-path conj ident)))\n                  :replace (let [path-to-vector (butlast data-path)\n                                 to-many?       (and (seq path-to-vector) (vector? (get-in state path-to-vector)))\n                                 index          (last data-path)\n                                 vector         (get-in state path-to-vector)]\n                             (assert (vector? data-path) (str \"Replacement path must be a vector. You passed: \" data-path))\n                             (when to-many?\n                               (do\n                                 (assert (vector? vector) \"Path for replacement must be a vector\")\n                                 (assert (number? index) \"Path for replacement must end in a vector index\")\n                                 (assert (contains? vector index) (str \"Target vector for replacement does not have an item at index \" index))))\n                             (assoc-in state data-path ident))\n                  (throw (ex-info \"Unknown post-op to merge-state!: \" {:command command :arg data-path})))))\n            state actions)))\n\n(defn process-target\n  ([state source-path target] (process-target state source-path target true))\n  ([state source-path target remove-ok?]\n   {:pre [(vector? target)]}\n   (let [item-to-place (cond (util/ident? source-path) source-path\n                             (keyword? source-path) (get state source-path)\n                             :else (get-in state source-path))\n         many-idents?  (and (vector? item-to-place)\n                            (every? util/ident? item-to-place))]\n     (cond\n       (and (util/ident? source-path)\n            (not (special-target? target))) (-> state\n                                                (assoc-in target item-to-place))\n       (not (special-target? target)) (cond->\n                                        (assoc-in state target item-to-place)\n                                        remove-ok? (dissoc source-path))\n       (multiple-targets? target) (cond-> (reduce (fn [s t] (process-target s source-path t false)) state target)\n                                    (and (not (util/ident? source-path)) remove-ok?) (dissoc source-path))\n       (and many-idents? (special-target? target)) (let [state            (if remove-ok?\n                                                                            (dissoc state source-path)\n                                                                            state)\n                                                         target-has-many? (vector? (get-in state target))]\n                                                     (if target-has-many?\n                                                       (cond\n                                                         (prepend-target? target) (update-in state target (fn [v] (vec (concat item-to-place v))))\n                                                         (append-target? target) (update-in state target (fn [v] (vec (concat v item-to-place))))\n                                                         :else state)\n                                                       (assoc-in state target item-to-place)))\n       (special-target? target) (cond-> state\n                                  remove-ok? (dissoc source-path)\n                                  (prepend-target? target) (integrate-ident item-to-place :prepend target)\n                                  (append-target? target) (integrate-ident item-to-place :append target)\n                                  (replacement-target? target) (integrate-ident item-to-place :replace target))\n       :else state))))\n"]}