{"version":3,"sources":["fulcro/client/impl/data_targeting.cljc"],"mappings":"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","names":["var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","fulcro.client.impl.data-targeting/multiple-targets","seq50112","self__4718__auto__","cljs.core/seq","targets","cljs.core/with-meta","cljs.core/vec","fulcro.client.impl.data-targeting/prepend-to","target","fulcro.client.impl.data-targeting/append-to","fulcro.client.impl.data-targeting/replace-at","fulcro.client.impl.data-targeting/replacement-target?","t","cljs.core/meta","cljs.core/boolean","fulcro.client.impl.data-targeting/prepend-target?","fulcro.client.impl.data-targeting/append-target?","fulcro.client.impl.data-targeting/multiple-targets?","fulcro.client.impl.data-targeting/special-target?","clojure.set.intersection.cljs$core$IFn$_invoke$arity$2","cljs.core/keys","cljs.core/set","fulcro.client.impl.data-targeting/integrate-ident","js/Error","seq50207","G__50208","cljs.core/first","cljs.core/next","G__50209","self__4717__auto__","state","ident","named-parameters","cljs.core/map?","actions","cljs.core.partition.cljs$core$IFn$_invoke$arity$2","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","p__50222","vec__50223","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","command","data-path","already-has-ident-at-path?","p1__50200#","cljs.core/some","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core.get_in.cljs$core$IFn$_invoke$arity$2","G__50226","cljs.core/Keyword","cljs.core/vector?","p1__50202#","cljs.core.update_in.cljs$core$IFn$_invoke$arity$3","cljs.core.into.cljs$core$IFn$_invoke$arity$2","cljs.core.update_in.cljs$core$IFn$_invoke$arity$4","cljs.core/conj","path-to-vector","cljs.core/butlast","to-many?","index","cljs.core/last","vector","cljs.core/contains?","cljs.core/assoc-in","cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2","G__50236","fulcro.client.impl.data-targeting/process-target","source-path","fulcro.client.impl.data_targeting.process_target.cljs$core$IFn$_invoke$arity$4","remove-ok?","item-to-place","fulcro.util/ident?","cljs.core.get.cljs$core$IFn$_invoke$arity$2","many-idents?","cljs.core/every?","G__50244","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","G__50247","s","and__4120__auto__","target-has-many?","v","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","G__50255","fulcro.client.impl.data_targeting.integrate_ident.cljs$core$IFn$_invoke$arity$variadic"],"sourcesContent":["(ns fulcro.client.impl.data-targeting\n  (:require [clojure.set :as set]\n            [fulcro.util :as util]))\n\n(defn multiple-targets [& targets]\n  (with-meta (vec targets) {::multiple-targets true}))\n\n(defn prepend-to [target]\n  (with-meta target {::prepend-target true}))\n\n(defn append-to [target]\n  (with-meta target {::append-target true}))\n\n(defn replace-at [target]\n  (with-meta target {::replace-target true}))\n\n(defn replacement-target? [t] (-> t meta ::replace-target boolean))\n(defn prepend-target? [t] (-> t meta ::prepend-target boolean))\n(defn append-target? [t] (-> t meta ::append-target boolean))\n(defn multiple-targets? [t] (-> t meta ::multiple-targets boolean))\n\n(defn special-target? [target]\n  (boolean (seq (set/intersection (-> target meta keys set) #{::replace-target ::append-target ::prepend-target ::multiple-targets}))))\n\n(defn integrate-ident\n  \"Integrate an ident into any number of places in the app state. This function is safe to use within mutation\n  implementations as a general helper function.\n\n  The named parameters can be specified any number of times. They are:\n\n  - append:  A vector (path) to a list in your app state where this new object's ident should be appended. Will not append\n  the ident if that ident is already in the list.\n  - prepend: A vector (path) to a list in your app state where this new object's ident should be prepended. Will not append\n  the ident if that ident is already in the list.\n  - replace: A vector (path) to a specific location in app-state where this object's ident should be placed. Can target a to-one or to-many.\n   If the target is a vector element then that element must already exist in the vector.\"\n  [state ident & named-parameters]\n  {:pre [(map? state)]}\n  (let [actions (partition 2 named-parameters)]\n    (reduce (fn [state [command data-path]]\n              (let [already-has-ident-at-path? (fn [data-path] (some #(= % ident) (get-in state data-path)))]\n                (case command\n                  :prepend (if (already-has-ident-at-path? data-path)\n                             state\n                             (do\n                               (assert (vector? (get-in state data-path)) (str \"Path \" data-path \" for prepend must target an app-state vector.\"))\n                               (update-in state data-path #(into [ident] %))))\n                  :append (if (already-has-ident-at-path? data-path)\n                            state\n                            (do\n                              (assert (vector? (get-in state data-path)) (str \"Path \" data-path \" for append must target an app-state vector.\"))\n                              (update-in state data-path conj ident)))\n                  :replace (let [path-to-vector (butlast data-path)\n                                 to-many?       (and (seq path-to-vector) (vector? (get-in state path-to-vector)))\n                                 index          (last data-path)\n                                 vector         (get-in state path-to-vector)]\n                             (assert (vector? data-path) (str \"Replacement path must be a vector. You passed: \" data-path))\n                             (when to-many?\n                               (do\n                                 (assert (vector? vector) \"Path for replacement must be a vector\")\n                                 (assert (number? index) \"Path for replacement must end in a vector index\")\n                                 (assert (contains? vector index) (str \"Target vector for replacement does not have an item at index \" index))))\n                             (assoc-in state data-path ident))\n                  (throw (ex-info \"Unknown post-op to merge-state!: \" {:command command :arg data-path})))))\n            state actions)))\n\n(defn process-target\n  ([state source-path target] (process-target state source-path target true))\n  ([state source-path target remove-ok?]\n   {:pre [(vector? target)]}\n   (let [item-to-place (cond (util/ident? source-path) source-path\n                             (keyword? source-path) (get state source-path)\n                             :else (get-in state source-path))\n         many-idents?  (and (vector? item-to-place)\n                            (every? util/ident? item-to-place))]\n     (cond\n       (and (util/ident? source-path)\n            (not (special-target? target))) (-> state\n                                                (assoc-in target item-to-place))\n       (not (special-target? target)) (cond->\n                                        (assoc-in state target item-to-place)\n                                        remove-ok? (dissoc source-path))\n       (multiple-targets? target) (cond-> (reduce (fn [s t] (process-target s source-path t false)) state target)\n                                    (and (not (util/ident? source-path)) remove-ok?) (dissoc source-path))\n       (and many-idents? (special-target? target)) (let [state            (if remove-ok?\n                                                                            (dissoc state source-path)\n                                                                            state)\n                                                         target-has-many? (vector? (get-in state target))]\n                                                     (if target-has-many?\n                                                       (cond\n                                                         (prepend-target? target) (update-in state target (fn [v] (vec (concat item-to-place v))))\n                                                         (append-target? target) (update-in state target (fn [v] (vec (concat v item-to-place))))\n                                                         :else state)\n                                                       (assoc-in state target item-to-place)))\n       (special-target? target) (cond-> state\n                                  remove-ok? (dissoc source-path)\n                                  (prepend-target? target) (integrate-ident item-to-place :prepend target)\n                                  (append-target? target) (integrate-ident item-to-place :append target)\n                                  (replacement-target? target) (integrate-ident item-to-place :replace target))\n       :else state))))\n"]}